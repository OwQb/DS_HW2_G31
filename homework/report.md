# 41243256
# 41243215

## 解題說明
### 題目一:Max/Min Heap實作
已知MaxPQ的抽象類如圖所示  
![Not_Found](/homework/report_image/PQ.png)  
請參考上圖實作出該抽象類別PQ(Max和Min)的完整程式  
並檢測以下兩者對應函式的時間複雜度是否相同  
IsEmpty()//時間複雜度應為O(1)  
Top()//時間複雜度應為O(1)  
Push(const T&)//時間複雜度應為O(log n)  
Pop()//時間複雜度應為O(log n)  
### 題目二:Binary Search Tree實作
1. 寫一個程序，從一棵原本為空的二元搜尋樹開始，並進行 n 次隨機插入。使用均勻隨機數產生器來取得要插入的值。測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。驗證這是否是這樣。  
2. 寫一個 C++ 函數，從二元搜尋樹中刪除鍵為k的對。你的函數的時間複雜度是多少？
### 題目三:緩衝區演算法計算  
【緩衝區演算法的步驟】 
|---|
|步驟1:輸入所有k個行程的第一個區塊,建立k個鏈結佇列,每個都有一個區塊的資料。把其餘的k個輸入區塊放入一個鏈結堆疊,裡頭都是閒置的輸入區塊。設定ou為0。|
|步驟2:令lastKey[i]是行程i的最後一個鍵值。令nextRun是lastKey最小的行程。如果lastKey[i]≠+∞,那麼啟動從行程nextRun的下一個區塊的輸入。|
|步驟3:使用函式Kwaymerge把k個輸入佇列的記錄合併到輸出緩衝區ou。合併持續到輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中。如果在合併的過程中,一個輸入緩衝區在輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中之前變空了,那麼Kwaymerge會使用同一個佇列的下一個緩衝區,並且把這個空的緩衝區放到空緩衝區的堆疊。但是,如果一個輸入緩衝區在輸出緩衝區正好填滿了或是一個鍵值為+∞的記錄合併到ou時剛好變成空的,那麼這個緩衝區會被留在佇列上,而Kwaymerge也不再往前進行到這個佇列的下一個緩衝區。反之,合併終止。|
|步驟4:等待任一個進行中的磁碟輸入/輸出動作完成。|
|步驟5:如果一個輸入緩衝區已經讀好,把它加入對應行程的佇列。藉由找出使得lastKey [nextRun]為最小的nextRun來決定下一個要讀入的行程。|
|步驟6:如果lastKey[nextRum]≠+∞,那麼開始從行程nextRun讀入下一個區塊到閒置的輸入緩衝區。|
|步驟7:開始寫出至輸出緩衝區ou。設ou為1-ou。|
|步驟8:如果一個鍵值為+∞的記錄還沒被合併到輸出緩衝區中,那麼回到步驟3。否則,等到進行中的寫入動作完成後停止。|

▲程式7.21:使用浮動緩衝區所做的k路合併  
  
1. n筆記錄要在一台記憶體容量為S的電腦上做排序，其中S << n。假
設這整個S-記錄的容量都可以用來做為輸入/輸出的緩衝區。輸入
的記錄儲存在磁碟上，包含m個行程。假設每次存取磁碟機時的搜
尋時間是t<sub>s</sub>而延遲時間則是t<sub>1</sub>。傳送每筆記錄的傳輸時間是t<sub>t</sub>。如果
我們採用k-路合併並且將內部記憶體切割以使得我們可以像演算法
Buffering(程式7.21)那樣地平行處理輸入、輸出、以及CPU運算，
那麼外部排序的第二個回合的總輸入時間為何?

2. 假設CPU合併所有的行程需要t<sub>cpu</sub>的時間(我們可以假設它跟k無關,因此是一個常數)。令t<sub>s</sub>=80ms，t<sub>1</sub>=20ms，n=200,000，m=64,t<sub>t</sub>=
$10^{-3}$秒/記錄，而且S=2000。粗略畫出一個總輸入時間t<sub>input</sub>對k的
函數圖形。是否一定有一個k值使得t<sub>cpu</sub> ≈ t<sub>input</sub>?
### 解題策略
#### 題目一
Max/Min Heap的抽象類都是相同的，只是內部執行的程序不同，所以我們可以共用一個抽象類來執行  
之後分別寫出詳細的Max/Min Heap的程式碼，測試時先建立一個大小為具有元素 n = 1000, 2000, 3000,... ,10000個的空白樹  
然後push填滿隨機值至該樹，最後就能量測Max/Min Heap在具有n個元素下執行各函式的時間  
#### 題目二
建立一個空的二元搜尋樹，使用均勻隨機數產生器進行 n 次隨機插入，隨後測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。得到比率高度 log2n 作為 n 函數的值。並且此比率應大致恆定（約2）。  
#### 題目三
根據程式7.21推測出第二個回合t<sub>input</sub>的時間公式，再分別帶入數值試著反推k值

## 效能分析
### Max/Min Heap
1. **IsEmpty()**   
  這個函式只做一個簡單的比較  
  沒有用到迴圈或遞迴，僅花費固定時間  
  因此時間複雜度是 O(1)

2. **Top()**  
  這個函式只是回傳 heap[1]（堆頂元素）  
  不需要遍歷堆，也沒有移動元素  
  因此時間複雜度是 O(1)  

3. **Push(const T&)**  
  插入時，先把新元素放到最後一個位置（O(1)）  
  然後進行「上浮調整」：  
  每次與父節點比較並可能交換（最多log(n)次）  
  因為堆是完全二元樹，樹高最多log(n)  
  因此時間複雜度為 O(log n)  

4. **Pop()**  
  移除堆頂後，最後一個元素 lastE 被提到頂部  
  然後進行「下沉調整」：  
  每次與較小的子節點比較並可能交換  
  最多調整 log(n) 層  
  因此時間複雜度為 O(log n)  

### Binary Search Tree
1. **為何繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）?**  
   若將 n 個節點隨機插入二元搜尋樹，所形成的 BST 是隨機形狀的 BST，  
   理論上，隨機插入下的 BST 平均高度為 O(log n)，實際上其常數因子約為 c ≈ 4.311（但中位數高度的常數約為 c ≈ 2）。  
   log(n) 是最佳情況下平衡 BST 的高度（例如 AVL 或紅黑樹的高度下界），  
   隨機插入會導致 BST 高度略高於 log(n)，但平均仍維持在相同階數，  
   因此高度除以 log(n)，也就是：比率 = 高度 / log(n)  
   將會是個約略恆定的數值，通常介於 1.3 到 2.5，根據不同的 n 值會略有波動。
   所以繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。  
    
2. **從二元搜尋樹中刪除鍵為k的對時間複雜度應是多少?**  
   刪除時會先搜尋目標節點 key ，其時間複雜度是與高度成正比，隨後可能需要找後繼節點（即右子樹最小值） 也是一條向下走的路徑，最後更新指標、刪除節點。  
   若樹的高度為 h，則：搜尋、插入、刪除的最壞時間複雜度皆為 O(h)，在隨機 BST 中，h ≈ c * log(n)，  
   因此刪除的期望時間為 log(n)。

## 程式實作
### Max/Min Heap實作
#### PQ抽象類別
|![Not_Found](/homework/report_image/MaxMinPQ.png)|定義四個純虛擬函式和Max/Min Heap共用：<br>IsEmpty()：判斷是否為空。<br>Top()：回傳堆頂元素（最小值或最大值）。<br>Push()：插入元素。<br>Pop()：刪除堆頂元素。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 繼承抽象基底類別 PQ<T>
|![Not_Found](/homework/report_image/MinPQ.png)|封裝了 MinHeap 的資料結構與基本操作)，使用陣列（從 index 1 開始）儲存二元樹結構，並且插入與刪除都保持MinHeap的性質（每個節點都小於等於其子節點），可自動擴充容量以支援更多元素，和提供抽象基底類別 PQ 介面。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別的建構子
|![Not_Found](/homework/report_image/MinHeap.png)|檢查使用者輸入的容量是否合理，並且初始化內部狀態（容量、當前堆大小），配置記憶體空間來儲存堆的元素（從 index 1 開始使用，以便維持二元樹的結構性質）。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中成員函式 Top()
|![Not_Found](/homework/report_image/MinTop.png)|傳回堆頂元素（最小元素）若堆為空，會丟出例外。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的私有輔助函式 ChangeSize1D()
|![Not_Found](/homework/report_image/MinChangeSize1D.png)|當堆滿了，就將容量擴充為原來的兩倍，並且檢查 newSize，避免記憶體洩漏。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的插入函式 Push()
|![Not_Found](/homework/report_image/MinPush.png)|當堆滿了，就將容量擴充為原來的兩倍，並且將新元素放在最尾端（heapSize + 1），隨後自底向上比較父節點與 e，進行上浮調整倍，然後找到正確位置後放入 e 。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的刪除堆頂元素函式 Pop()
|![Not_Found](/homework/report_image/MinPop.png)|若堆空，拋出例外，取出最後一個元素 lastE 來替代堆頂，並且自頂向下調整（用較小的子節點遞補），最後將 lastE 放入適當位置。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 繼承抽象基底類別 PQ<T>
|![Not_Found](/homework/report_image/MaxPQ.png)|封裝了 MaxHeap 的資料結構與基本操作，使用陣列（從 index 1 開始）儲存完全二元樹結構，並在插入與刪除時維持最大堆的性質（每個節點都大於等於其子節點），可自動擴充容量以容納更多元素，和提供抽象基底類別 PQ 介面。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別的建構子
|![Not_Found](/homework/report_image/MaxHeap.png)|檢查使用者輸入的容量是否合理，並且初始化內部狀態（容量、當前堆大小），配置記憶體空間來儲存堆的元素（從 index 1 開始使用，以便維持二元樹的結構性質）。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中成員函式 Top()
|![Not_Found](/homework/report_image/MaxTop.png)|傳回堆頂元素（最大元素），若堆為空，會丟出例外。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的私有輔助函式 ChangeSize1D()
|![Not_Found](/homework/report_image/MaxChangeSize1D.png)|當堆滿了，就將容量擴充為原來的兩倍，並且檢查 newSize，避免記憶體洩漏。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的插入函式 Push()
|![Not_Found](/homework/report_image/MaxPush.png)|當堆滿了，就將容量擴充為原來的兩倍，再將新元素插入尾端，並自底向上與父節點比較，若比父節點大則進行上浮，直到符合最大堆的性質，最後將新元素放入正確位置。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的刪除堆頂元素函式 Pop()
|![Not_Found](/homework/report_image/MaxPop.png)|若堆為空則拋出例外，否則取出最後一個元素作為替代堆頂的值，從頂部開始與兩個子節點中較大的節點比較，若小於子節點則下沉交換，最後放入正確位置以維持最大堆性質。|
|:----------------------------------------------|:-----------------------------------------|
#### 測試函式
|![Not_Found](/homework/report_image/BenchmarkHeap_01.png)|建立n = 1000, 2000, 3000,... ,10000的陣列和設定repeat = 10000測試次數|
|:----------------------------------------------|:-----------------------------------------|
|![Not_Found](/homework/report_image/BenchmarkHeap_02.png)|**從n[0]跑到陣列結束，建立一個空的 Heap 後用隨機數填滿樹**|
|![Not_Found](/homework/report_image/BenchmarkHeap_03.png)|**因為單次運行時間過短難以進行量測，所以執行repeat = 10000次後取平均數**|
|![Not_Found](/homework/report_image/BenchmarkHeap_04.png)|**採用n[0]的量測值作為之後的推測，並輸出結果**|
#### main函式
|![Not_Found](/homework/report_image/MaxMinHeapmain.png)|執行Max/Min Heap測試函式|
|:----------------------------------------------|:-----------------------------------------|
### Binary Search Tree實作
#### xx函式
|![Not_Found](/homework/report_image/.png)|xx函式<br>說明|
|:----------------------------------------------|:-----------------------------------------|
#### xx函式
|![Not_Found](/homework/report_image/.png)|xx函式<br>說明|
|:----------------------------------------------|:-----------------------------------------|
#### xx函式
|![Not_Found](/homework/report_image/.png)|xx函式<br>說明|
|:----------------------------------------------|:-----------------------------------------|
#### xx函式
|![Not_Found](/homework/report_image/.png)|xx函式<br>說明|
|:----------------------------------------------|:-----------------------------------------|
## 測試與驗證

### 測試輸出結果

## 申論及開發報告

### 申論

### 開發報告

