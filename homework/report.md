# 41243256
# 41243215

## 解題說明
### 題目一:Max/Min Heap實作
已知MaxPQ的抽象類如圖所示  
![Not_Found](/homework/report_image/PQ.png)  
請參考上圖實作出該抽象類別PQ(Max和Min)的完整程式  
並檢測以下兩者對應函式的時間複雜度是否相同  
IsEmpty()//時間複雜度應為O(1)  
Top()//時間複雜度應為O(1)  
Push(const T&)//時間複雜度應為O(log n)  
Pop()//時間複雜度應為O(log n)  
### 題目二:Binary Search Tree實作
1.寫一個程序，從一棵原本為空的二元搜尋樹開始，並進行 n 次隨機插入。使用均勻隨機數產生器來取得要插入的值。測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。驗證這是否是這樣。  
2.寫一個 C++ 函數，從二元搜尋樹中刪除鍵為k的對。你的函數的時間複雜度是多少？
### 題目三:緩衝區演算法計算  
【緩衝區演算法的步驟】 
|---|
|步驟1:輸入所有k個行程的第一個區塊,建立k個鏈結佇列,每個都有一個區塊的資料。把其餘的k個輸入區塊放入一個鏈結堆疊,裡頭都是閒置的輸入區塊。設定ou為0。|
|步驟2:令lastKey[i]是行程i的最後一個鍵值。令nextRun是lastKey最小的行程。如果lastKey[i]≠+∞,那麼啟動從行程nextRun的下一個區塊的輸入。|
|步驟3:使用函式Kwaymerge把k個輸入佇列的記錄合併到輸出緩衝區ou。合併持續到輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中。如果在合併的過程中,一個輸入緩衝區在輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中之前變空了,那麼Kwaymerge會使用同一個佇列的下一個緩衝區,並且把這個空的緩衝區放到空緩衝區的堆疊。但是,如果一個輸入緩衝區在輸出緩衝區正好填滿了或是一個鍵值為+∞的記錄合併到ou時剛好變成空的,那麼這個緩衝區會被留在佇列上,而Kwaymerge也不再往前進行到這個佇列的下一個緩衝區。反之,合併終止。|
|步驟4:等待任一個進行中的磁碟輸入/輸出動作完成。|
|步驟5:如果一個輸入緩衝區已經讀好,把它加入對應行程的佇列。藉由找出使得lastKey [nextRun]為最小的nextRun來決定下一個要讀入的行程。|
|步驟6:如果lastKey[nextRum]≠+∞,那麼開始從行程nextRun讀入下一個區塊到閒置的輸入緩衝區。|
|步驟7:開始寫出至輸出緩衝區ou。設ou為1-ou。|
|步驟8:如果一個鍵值為+∞的記錄還沒被合併到輸出緩衝區中,那麼回到步驟3。否則,等到進行中的寫入動作完成後停止。|

▲程式7.21:使用浮動緩衝區所做的k路合併  
  
1.n筆記錄要在一台記憶體容量為S的電腦上做排序，其中S << n。假
設這整個S-記錄的容量都可以用來做為輸入/輸出的緩衝區。輸入
的記錄儲存在磁碟上，包含m個行程。假設每次存取磁碟機時的搜
尋時間是t<sub>s</sub>而延遲時間則是t<sub>1</sub>。傳送每筆記錄的傳輸時間是t<sub>t</sub>。如果
我們採用k-路合併並且將內部記憶體切割以使得我們可以像演算法
Buffering(程式7.21)那樣地平行處理輸入、輸出、以及CPU運算，
那麼外部排序的第二個回合的總輸入時間為何?

2.假設CPU合併所有的行程需要t<sub>cpu</sub>的時間(我們可以假設它跟k無關,因此是一個常數)。令t<sub>s</sub>=80ms，t<sub>1</sub>=20ms，n=200,000，m=64,t<sub>t</sub>=
$10^{-3}$秒/記錄，而且S=2000。粗略畫出一個總輸入時間t<sub>input</sub>對k的
函數圖形。是否一定有一個k值使得t<sub>cpu</sub> ≈ t<sub>input</sub>?
### 解題策略
#### 題目一
Max/Min Heap的抽象類都是相同的，只是內部執行的程序不同，所以我們可以共用一個抽象類來執行  
之後分別寫出詳細的Max/Min Heap的程式碼，測試時先建立一個大小為具有元素 n = 1000, 2000, 3000,... ,10000個的空白樹  
然後push填滿隨機值至該樹，最後就能量測Max/Min Heap在具有n個元素下執行各函式的時間  
#### 題目二
建立一個空的二元搜尋樹，使用均勻隨機數產生器進行 n 次隨機插入，隨後測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。得到比率高度 log2n 作為 n 函數的值。並且此比率應大致恆定（約2）。  
#### 題目三
根據程式7.21推測出第二個回合t<sub>input</sub>的時間公式，再分別帶入數值試著反推k值

## 效能分析
### Max/Min Heap
1. **IsEmpty()**   
  這個函式只做一個簡單的比較  
  沒有用到迴圈或遞迴，僅花費固定時間  
  因此時間複雜度是 O(1)

2. **Top()**  
  這個函式只是回傳 heap[1]（堆頂元素）  
  不需要遍歷堆，也沒有移動元素  
  因此時間複雜度是 O(1)  

3. **Push(const T&)**  
  插入時，先把新元素放到最後一個位置（O(1)）  
  然後進行「上浮調整」：  
  每次與父節點比較並可能交換（最多log(n)次）  
  因為堆是完全二元樹，樹高最多log(n)  
  因此時間複雜度為 O(log n)  

4. **Pop()**  
  移除堆頂後，最後一個元素 lastE 被提到頂部  
  然後進行「下沉調整」：  
  每次與較小的子節點比較並可能交換  
  最多調整 log(n) 層  
  因此時間複雜度為 O(log n)  

### Binary Search Tree
1. **為何繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）?**  
   若將 n 個節點隨機插入二元搜尋樹，所形成的 BST 是隨機形狀的 BST，  
   理論上，隨機插入下的 BST 平均高度為 O(log n)，實際上其常數因子約為 c ≈ 4.311（但中位數高度的常數約為 c ≈ 2）。  
   log(n) 是最佳情況下平衡 BST 的高度（例如 AVL 或紅黑樹的高度下界），  
   隨機插入會導致 BST 高度略高於 log(n)，但平均仍維持在相同階數，  
   因此高度除以 log(n)，也就是：比率 = 高度 / log(n)  
   將會是個約略恆定的數值，通常介於 1.3 到 2.5，根據不同的 n 值會略有波動。
   所以繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。  
    
2. **從二元搜尋樹中刪除鍵為k的對時間複雜度應是多少?**  
   刪除時會先搜尋目標節點 key ，其時間複雜度是與高度成正比，隨後可能需要找後繼節點（即右子樹最小值） 也是一條向下走的路徑，最後更新指標、刪除節點。  
   若樹的高度為 h，則：搜尋、插入、刪除的最壞時間複雜度皆為 O(h)，在隨機 BST 中，h ≈ c * log(n)，  
   因此刪除的期望時間為 log(n)。

## 程式實作
### Max/Min Heap實作
|![Not_Found](/homework/report_image/.png)|xx函式<br>說明|
|:----------------------------------------------|:-----------------------------------------|
## 測試與驗證

### 測試輸出結果

## 申論及開發報告

### 申論

### 開發報告

