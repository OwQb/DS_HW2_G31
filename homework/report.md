# 41243256
# 41243215

## 解題說明
### 題目一:Max/Min Heap實作
已知MaxPQ的抽象類如圖所示  
![Not_Found](/homework/report_image/PQ.png)  
請參考上圖實作出該抽象類別PQ(Max和Min)的完整程式  
並檢測以下兩者對應函式的時間複雜度是否相同  
IsEmpty()//時間複雜度應為O(1)  
Top()//時間複雜度應為O(1)  
Push(const T&)//時間複雜度應為O(log n)  
Pop()//時間複雜度應為O(log n)  
### 題目二:Binary Search Tree實作
1. 寫一個程序，從一棵原本為空的二元搜尋樹開始，並進行 n 次隨機插入。使用均勻隨機數產生器來取得要插入的值。測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。驗證這是否是這樣。  
2. 寫一個 C++ 函數，從二元搜尋樹中刪除鍵為k的對。你的函數的時間複雜度是多少？
### 題目三:緩衝區演算法  
【緩衝區演算法的步驟】 
|---|
|步驟1:輸入所有k個行程的第一個區塊,建立k個鏈結佇列,每個都有一個區塊的資料。把其餘的k個輸入區塊放入一個鏈結堆疊,裡頭都是閒置的輸入區塊。設定ou為0。|
|步驟2:令lastKey[i]是行程i的最後一個鍵值。令nextRun是lastKey最小的行程。如果lastKey[i]≠+∞,那麼啟動從行程nextRun的下一個區塊的輸入。|
|步驟3:使用函式Kwaymerge把k個輸入佇列的記錄合併到輸出緩衝區ou。合併持續到輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中。如果在合併的過程中,一個輸入緩衝區在輸出緩衝區填滿了或是一個鍵值為+∞的記錄合併到ou中之前變空了,那麼Kwaymerge會使用同一個佇列的下一個緩衝區,並且把這個空的緩衝區放到空緩衝區的堆疊。但是,如果一個輸入緩衝區在輸出緩衝區正好填滿了或是一個鍵值為+∞的記錄合併到ou時剛好變成空的,那麼這個緩衝區會被留在佇列上,而Kwaymerge也不再往前進行到這個佇列的下一個緩衝區。反之,合併終止。|
|步驟4:等待任一個進行中的磁碟輸入/輸出動作完成。|
|步驟5:如果一個輸入緩衝區已經讀好,把它加入對應行程的佇列。藉由找出使得lastKey [nextRun]為最小的nextRun來決定下一個要讀入的行程。|
|步驟6:如果lastKey[nextRum]≠+∞,那麼開始從行程nextRun讀入下一個區塊到閒置的輸入緩衝區。|
|步驟7:開始寫出至輸出緩衝區ou。設ou為1-ou。|
|步驟8:如果一個鍵值為+∞的記錄還沒被合併到輸出緩衝區中,那麼回到步驟3。否則,等到進行中的寫入動作完成後停止。|

▲程式7.21:使用浮動緩衝區所做的k路合併  
  
1. n筆記錄要在一台記憶體容量為S的電腦上做排序，其中S << n。假
設這整個S-記錄的容量都可以用來做為輸入/輸出的緩衝區。輸入
的記錄儲存在磁碟上，包含m個行程。假設每次存取磁碟機時的搜
尋時間是t<sub>s</sub>而延遲時間則是t<sub>1</sub>。傳送每筆記錄的傳輸時間是t<sub>t</sub>。如果
我們採用k-路合併並且將內部記憶體切割以使得我們可以像演算法
Buffering(程式7.21)那樣地平行處理輸入、輸出、以及CPU運算，
那麼外部排序的第二個回合的總輸入時間為何?

2. 假設CPU合併所有的行程需要t<sub>cpu</sub>的時間(我們可以假設它跟k無關,因此是一個常數)。令t<sub>s</sub>=80ms，t<sub>1</sub>=20ms，n=200,000，m=64,t<sub>t</sub>=
$10^{-3}$秒/記錄，而且S=2000。粗略畫出一個總輸入時間t<sub>input</sub>對k的
函數圖形。是否一定有一個k值使得t<sub>cpu</sub> ≈ t<sub>input</sub>?
### 解題策略
#### 題目一
Max/Min Heap的抽象類都是相同的，只是內部執行的程序不同，所以我們可以共用一個抽象類來執行  
之後分別寫出詳細的Max/Min Heap的程式碼，測試時先建立一個大小為具有元素 n = 1000, 2000, 3000,... ,10000個的空白樹  
然後push填滿隨機值至該樹，最後就能量測Max/Min Heap在具有n個元素下執行各函式的時間  
#### 題目二
建立一個空的二元搜尋樹，使用均勻隨機數產生器進行 n 次隨機插入，隨後測量產生的二元搜尋樹的高度並將該高度除以 log2n。
對 n = 100, 500, 1000, 2000, 3000, ..., 10,000 執行此操作。得到比率高度 log2n 作為 n 函數的值。並且此比率應大致恆定（約2）。  
#### 題目三
根據程式7.21推測出第二個回合t<sub>input</sub>的時間公式，再分別帶入數值試著反推k值

## 效能分析
### Max/Min Heap
1. **IsEmpty()**   
  這個函式只做一個簡單的比較  
  沒有用到迴圈或遞迴，僅花費固定時間  
  因此時間複雜度是 O(1)

2. **Top()**  
  這個函式只是回傳 heap[1]（堆頂元素）  
  不需要遍歷堆，也沒有移動元素  
  因此時間複雜度是 O(1)  

3. **Push(const T&)**  
  插入時，先把新元素放到最後一個位置（O(1)）  
  然後進行「上浮調整」：  
  每次與父節點比較並可能交換（最多log(n)次）  
  因為堆是完全二元樹，樹高最多log(n)  
  因此時間複雜度為 O(log n)  

4. **Pop()**  
  移除堆頂後，最後一個元素 lastE 被提到頂部  
  然後進行「下沉調整」：  
  每次與較小的子節點比較並可能交換  
  最多調整 log(n) 層  
  因此時間複雜度為 O(log n)  

### Binary Search Tree
1. **為何繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）?**  
   若將 n 個節點隨機插入二元搜尋樹，所形成的 BST 是隨機形狀的 BST，  
   理論上，隨機插入下的 BST 平均高度為 O(log n)，實際上其常數因子約為 c ≈ 4.311（但中位數高度的常數約為 c ≈ 2）。  
   log(n) 是最佳情況下平衡 BST 的高度（例如 AVL 或紅黑樹的高度下界），  
   隨機插入會導致 BST 高度略高於 log(n)，但平均仍維持在相同階數，  
   因此高度除以 log(n)，也就是：比率 = 高度 / log(n)  
   將會是個約略恆定的數值，通常介於 1.3 到 2.5，根據不同的 n 值會略有波動。
   所以繪製比率高度 log2n 作為 n 的函數。此比率應大致恆定（約2）。  
    
2. **從二元搜尋樹中刪除鍵為k的對時間複雜度應是多少?**  
   刪除時會先搜尋目標節點 key ，其時間複雜度是與高度成正比，隨後可能需要找後繼節點（即右子樹最小值） 也是一條向下走的路徑，最後更新指標、刪除節點。  
   若樹的高度為 h，則：搜尋、插入、刪除的最壞時間複雜度皆為 O(h)，在隨機 BST 中，h ≈ c * log(n)，  
   因此刪除的期望時間為 log(n)。
### 緩衝區演算法計算
1. 外部排序第二回合的目標是把所有 m 個行程透過多次 k-way merge 合併成一個完整排序的行程。假設一次合併 k 個行程，就會有：  
合併次數（rounds）≈ ⌈log<sub>k</sub> m⌉<br><br>
總輸入時間 t_input，也就是把所有 n 筆資料從磁碟讀入主記憶體所花費的時間，    
每次從磁碟讀一個區塊的時間包含：  
搜尋時間 t<sub>s</sub>  
延遲時間 t<sub>1</sub>  
傳送時間 n ． t<sub>t</sub>  
總共需要讀取 n 筆資料，在合併過程中每筆資料都要至少讀一次。<br><br> 
所以總輸入時間為：t<sub>input</sub> = ( ${n} \over  {B}$ ) ． (t<sub>s</sub> + t<sub>1</sub>) + n ． t<sub>t</sub>
其中：  
B 是區塊大小（每次讀入多少筆記錄）  
${n} \over  {B}$ 是總共要進行多少次磁碟 I/O 區塊讀取  
但根據題意，記憶體大小為 S，且分為 k 個輸入緩衝區 + 1 個輸出緩衝區，所以每個緩衝區大小約為：  
B = ${S} \over  {k+1}$  
代入後，輸入區塊數量為：  
${n} \over  {B}$ = ${n(k+1)} \over  {S}$<br><br> 
**因此總輸入時間為：  
t<sub>input</sub>(k) = ${n(k+1)} \over {S}$ ． (t<sub>s</sub> + t<sub>1</sub>) + n ． t<sub>t</sub><br><br>**
2. 根據題目已知  
t<sub>s</sub>  = 80 ms = 0.08 秒  
t<sub>1</sub>  = 20 ms = 0.02 秒  
t<sub>t</sub>  = $10^{-3}$ = 0.001秒/記錄  
n = 200000  
S = 2000（記憶體可放 2000 筆記錄）<br><br>
代入總輸入時間公式：  
t<sub>input</sub>(k) = ${200000(k+1)} \over {2000}$ ． (0.02 + 0.08) + 200000 ． 0.001  
化簡：  
t<sub>input</sub>(k) = 100(k+1)(0.1)+200 = 10(k+1)+200 = 10k+210 秒<br><br>
檢驗是否存在使得 t<sub>cpu</sub> ≈ t<sub>input</sub> 的 k 值可以先假設：
t<sub>cpu</sub> = 500 秒  
帶入公式：  
t<sub>input</sub>(k) ⇒ t<sub>cpu</sub> 10k+210=500 ⇒ k = ${290} \over {10}$ = 29<br><br>
**得知當t<sub>cpu</sub>=500時 k = 29 ，所以的確存在某個 k 值使得 t_input ≈ t_cpu，這個 k 值可以透過解方程來找出，並達成 CPU 與 I/O 負載平衡**
## 程式實作
### Max/Min Heap實作
#### PQ抽象類別
|![Not_Found](/homework/report_image/MaxMinPQ.png)|定義四個純虛擬函式和Max/Min Heap共用：<br>IsEmpty()：判斷是否為空。<br>Top()：回傳堆頂元素（最小值或最大值）。<br>Push()：插入元素。<br>Pop()：刪除堆頂元素。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 繼承抽象基底類別 PQ<T>
|![Not_Found](/homework/report_image/MinPQ.png)|封裝了 MinHeap 的資料結構與基本操作)，使用陣列（從 index 1 開始）儲存二元樹結構，並且插入與刪除都保持MinHeap的性質（每個節點都小於等於其子節點），可自動擴充容量以支援更多元素，和提供抽象基底類別 PQ 介面。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別的建構子
|![Not_Found](/homework/report_image/MinHeap.png)|檢查使用者輸入的容量是否合理，並且初始化內部狀態（容量、當前堆大小），配置記憶體空間來儲存堆的元素（從 index 1 開始使用，以便維持二元樹的結構性質）。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中成員函式 Top()
|![Not_Found](/homework/report_image/MinTop.png)|傳回堆頂元素（最小元素）若堆為空，會丟出例外。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的私有輔助函式 ChangeSize1D()
|![Not_Found](/homework/report_image/MinChangeSize1D.png)|當堆滿了，就將容量擴充為原來的兩倍，並且檢查 newSize，避免記憶體洩漏。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的插入函式 Push()
|![Not_Found](/homework/report_image/MinPush.png)|當堆滿了，就將容量擴充為原來的兩倍，並且將新元素放在最尾端（heapSize + 1），隨後自底向上比較父節點與 e，進行上浮調整倍，然後找到正確位置後放入 e 。|
|:----------------------------------------------|:-----------------------------------------|
#### MinHeap 類別中的刪除堆頂元素函式 Pop()
|![Not_Found](/homework/report_image/MinPop.png)|若堆空，拋出例外，取出最後一個元素 lastE 來替代堆頂，並且自頂向下調整（用較小的子節點遞補），最後將 lastE 放入適當位置。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 繼承抽象基底類別 PQ<T>
|![Not_Found](/homework/report_image/MaxPQ.png)|封裝了 MaxHeap 的資料結構與基本操作，使用陣列（從 index 1 開始）儲存完全二元樹結構，並在插入與刪除時維持最大堆的性質（每個節點都大於等於其子節點），可自動擴充容量以容納更多元素，和提供抽象基底類別 PQ 介面。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別的建構子
|![Not_Found](/homework/report_image/MaxHeap.png)|檢查使用者輸入的容量是否合理，並且初始化內部狀態（容量、當前堆大小），配置記憶體空間來儲存堆的元素（從 index 1 開始使用，以便維持二元樹的結構性質）。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中成員函式 Top()
|![Not_Found](/homework/report_image/MaxTop.png)|傳回堆頂元素（最大元素），若堆為空，會丟出例外。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的私有輔助函式 ChangeSize1D()
|![Not_Found](/homework/report_image/MaxChangeSize1D.png)|當堆滿了，就將容量擴充為原來的兩倍，並且檢查 newSize，避免記憶體洩漏。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的插入函式 Push()
|![Not_Found](/homework/report_image/MaxPush.png)|當堆滿了，就將容量擴充為原來的兩倍，再將新元素插入尾端，並自底向上與父節點比較，若比父節點大則進行上浮，直到符合最大堆的性質，最後將新元素放入正確位置。|
|:----------------------------------------------|:-----------------------------------------|
#### MaxHeap 類別中的刪除堆頂元素函式 Pop()
|![Not_Found](/homework/report_image/MaxPop.png)|若堆為空則拋出例外，否則取出最後一個元素作為替代堆頂的值，從頂部開始與兩個子節點中較大的節點比較，若小於子節點則下沉交換，最後放入正確位置以維持最大堆性質。|
|:----------------------------------------------|:-----------------------------------------|
#### 測試函式
|![Not_Found](/homework/report_image/BenchmarkHeap_01.png)|建立n = 1000, 2000, 3000,... ,10000的陣列和設定repeat = 10000測試次數|
|:----------------------------------------------|:-----------------------------------------|
|![Not_Found](/homework/report_image/BenchmarkHeap_02.png)|**從n[0]跑到陣列結束，建立一個空的 Heap 後用隨機數填滿樹**|
|![Not_Found](/homework/report_image/BenchmarkHeap_03.png)|**因為單次運行時間過短難以進行量測，所以執行repeat = 10000次後取平均數**|
|![Not_Found](/homework/report_image/BenchmarkHeap_04.png)|**採用n[0]的量測值作為之後的推測，並輸出結果**|
#### main 函式
|![Not_Found](/homework/report_image/MaxMinHeapmain.png)|執行Max/Min Heap測試函式|
|:----------------------------------------------|:-----------------------------------------|
### Binary Search Tree實作
#### 抽象類別 Dictionary<K, E>
|![Not_Found](/homework/report_image/BST_Dictionary.png)|抽象類別 Dictionary<K, E>，是所有字典類別的接口，包含以下純虛擬函式：<brIsEmpty(): 判斷字典是否為空。<br>Get(const K&): 依照 key 取得對應的 pair<K, E> 指標，如果不存在則回傳 nullptr。<br>Insert(const pair<K, E>&): 插入一筆鍵值對（key-value pair）。若 key 已存在則更新值。<br>Delete(const K&): 根據 key 刪除一筆鍵值對。<br>|
|:----------------------------------------------|:-----------------------------------------|
#### 節點類別 TreeNode<K, E>
|![Not_Found](/homework/report_image/BST_TreeNode.png)|每個節點包含left 和 right 指標，指向左右子節點，一個 pair<K, E> 型別的 data 成員，儲存該節點的 key 與對應 value，節點建構子會以傳入的 pair<K,E> 初始化鍵值對資料，其左右子節點初始為 nullptr。|
|:----------------------------------------------|:-----------------------------------------|
#### 實現 Dictionary<K,E> 的函式
|![Not_Found](/homework/report_image/BST_D.png)|使用 二元搜尋樹 (BST) 作為內部資料結構：<br>root 是整棵樹的根節點。<br>clearTree() 是遞迴的私有函式，用來在解構時釋放所有節點，防止記憶體洩漏。<br>|
|:----------------------------------------------|:-----------------------------------------|
|![Not_Found](/homework/report_image/TN_insertNode.png)|**遞迴插入節點的函式 insertNode()：<br>若目前節點為空，則直接建立一個新節點。<br>若新 key 比目前節點的 key 小，就往左子樹遞迴插入。<br>若新 key 大，則往右子樹插入。<br>若 key 相同，則直接更新 value<br>**|
#### findNode 和 findMin 函式
|![Not_Found](/homework/report_image/TN_findNode_findMin.png)|findNode 搜尋時可以像「二分搜尋」一樣往左或右子樹遞迴：<br>若 key < node->data.first：往左子樹找。<br>若 key > node->data.first：往右子樹找。<br>若相等：表示找到了，回傳該節點。<br><br>findMin 用來找到某個子樹中最小值節點，通常用在刪除節點時需要找中序後繼（successor）的情境：<br>BST 中最小值：一定在最左邊的節點。<br>所以只要一路往左找，直到 node->left == nullptr，就找到了最小值節點。|
|:----------------------------------------------|:-----------------------------------------|
#### deleteNode 函式
|![Not_Found](/homework/report_image/TN_deleteNode.png)|刪除節點的遞迴函式，分三種情況處理：<br>若該節點無子節點：直接刪除。<br>若只有一個子節點：用其子節點取代。<br>若有兩個子節點：找右子樹的最小值（後繼），取代該節點，再遞迴刪除後繼節點。<br>|
|:----------------------------------------------|:-----------------------------------------|
####  computeHeight 函式和定義BSTDictionary類別裡的介面函式
|![Not_Found](/homework/report_image/computeHeight.png)|computeHeight 如果目前節點是空的，回傳 0（代表子樹高度為 0）否則：<br>遞迴算出左子樹的高度 leftH。<br>遞迴算出右子樹的高度 rightH。<br>取兩者的較大值，再加上 1（代表目前這一層），就是整棵子樹的高度。<br><br>四個介面函式：<br>IsEmpty()：若 root 是 nullptr，表示 BST 裡沒有任何節點。<br>Insert(const pair<K, E>& entry)：調用私有的遞迴函式 insertNode ，若 key 已存在則更新 value，否則根據 BST 的規則插入到正確位置。<br>Delete(const K& key)：調用私有遞迴函式 deleteNode ，根據 BST 的性質找出該 key 並進行刪除。<br>Get(const K& key)：使用私有遞迴函式 findNode 進行查找，如果找到對應節點回傳其 data 的位址。<br>|
|:----------------------------------------------|:-----------------------------------------|
#### main 函式
|![Not_Found](/homework/report_image/BST_main_01.png)|要測試的各項 n 值，並設定亂數|
|:----------------------------------------------|:-----------------------------------------|
|![Not_Found](/homework/report_image/BST_main_02.png)|**建立一棵新的 BST ，隨機產生 n 個不重複 key 並插入 BST，同時記錄 key 以便後續刪除 ，隨後計算樹的實際高度、理論值 log n 和它們的比值，隨機從插入過的 key 中選一個，並進行刪除時間的測量，重複 10000 次後計算平均刪除時間**|
|![Not_Found](/homework/report_image/BST_main_03.png)|**根據首次執行的時間進行推斷，並輸出結果**|

## 測試與驗證
### 測試輸出結果
|![Not_Found](/homework/report_image/MaxMinHeap_output.png)|
|----------------------------------------------|

|![Not_Found](/homework/report_image/BST_output.png)|
|----------------------------------------------|

|![Not_Found](/homework/report_image/Figure_1.png)|
|----------------------------------------------|
## 申論及開發報告

### 申論

### 開發報告

